// fn rule110(l: s32, c: s32, r: s32) s32 {
//     let pattern = l * 4 + c * 2 + r;
//     // Rule110 = 0b01101110 = 110 in decimal
//     return (110 >> pattern) & 1;
// }
fn rule110(l: s32, c: s32, r: s32) s32 {
    if l == 1 and c == 1 and r == 1 { return 0; }
    if l == 1 and c == 1 and r == 0 { return 1; }
    if l == 1 and c == 0 and r == 1 { return 1; }
    if l == 1 and c == 0 and r == 0 { return 0; }
    if l == 0 and c == 1 and r == 1 { return 1; }
    if l == 0 and c == 1 and r == 0 { return 1; }
    if l == 0 and c == 0 and r == 1 { return 1; }
    return 0;
}

pub fn main() s32 {
    let mut current: [159; s32] = [0; 159];
    let mut next: [159; s32] = [0; 159];

    current[current.len - 1] = 1;

    let mut steps = 0;
    while true {
        let mut i = 0;
        while i < current.len {
            let left = if i == 0 { 0 } else { current[i - 1] };
            let center = current[i];
            let right = if i + 1 >= current.len { 0 } else { current[i + 1] };

            next[i] = rule110(left, center, right);
            i = i + 1;
        }

        i = 0;
        while i < current.len {
            if current[i] == 0 {
                write_char(32);
            }

            if current[i] == 1 {
                write_char(42);
            }
            current[i] = next[i];
            i = i + 1;
        }

        write_char(10);
        steps = steps + 1;
    }

    return current[0];
}
